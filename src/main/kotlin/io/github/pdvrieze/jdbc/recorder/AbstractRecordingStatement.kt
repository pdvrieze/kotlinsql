/*
 * Copyright (c) 2021.
 *
 * This file is part of kotlinsql.
 *
 * This file is licenced to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You should have received a copy of the license with the source distribution.
 * Alternatively, you may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package io.github.pdvrieze.jdbc.recorder

import io.github.pdvrieze.jdbc.recorder.actions.StatementClose
import java.sql.ResultSet
import java.sql.SQLWarning
import java.sql.Statement

abstract class AbstractRecordingStatement<D: Statement>(
    private val connection: RecordingConnection,
    delegate: D,
    open val sql: String? = null,
) : WrappingActionRecorder<D>(delegate), Statement {

    @get:JvmName("getIsClosed")
    protected var isClosed = false

    final override fun addBatch(sql: String?) = record {
        delegate.addBatch(sql)
    }

    final override fun clearWarnings() {
        record()
        delegate.clearWarnings()
    }

    final override fun closeOnCompletion() {
        record()
        delegate.closeOnCompletion()
    }

    final override fun cancel() {
        record()
        delegate.cancel()
    }

    final override fun clearBatch() = record {
        delegate.clearBatch()
    }

    final override fun close() {
        recordAction(StatementClose(sql))
        delegate.close()
    }

    final override fun execute(sql: String?): Boolean {
        return record(sql) {
            delegate.execute(sql)
        }
    }

    final override fun execute(sql: String?, autoGeneratedKeys: Int): Boolean {
        return record(sql, autoGeneratedKeys) {
            delegate.execute(sql, autoGeneratedKeys)
        }
    }

    final override fun execute(sql: String?, columnIndexes: IntArray?): Boolean {
        return record(sql, columnIndexes) {
            delegate.execute(sql, columnIndexes)
        }
    }

    final override fun execute(sql: String?, columnNames: Array<out String>?): Boolean {
        return record(sql, columnNames) {
            delegate.execute(sql, columnNames)
        }
    }

    final override fun executeBatch(): IntArray = record {
        delegate.executeBatch()
    }

    final override fun executeQuery(sql: String?): ResultSet = record {
        connection.RecordingResultSet(delegate.executeQuery(sql), sql?:"")
    }

    final override fun executeUpdate(sql: String?): Int = record(sql) {
        delegate.executeUpdate(sql)
    }

    final override fun executeUpdate(sql: String?, autoGeneratedKeys: Int): Int = record(sql, autoGeneratedKeys) {
        delegate.executeUpdate(sql, autoGeneratedKeys)
    }

    final override fun executeUpdate(sql: String?, columnIndexes: IntArray?): Int = record(sql, columnIndexes) {
        delegate.executeUpdate(sql, columnIndexes)
    }

    final override fun executeUpdate(sql: String?, columnNames: Array<out String>?): Int = record(sql, columnNames) {
        delegate.executeUpdate(sql, columnNames)
    }

    final override fun getConnection(): RecordingConnection = connection

    final override fun getFetchDirection(): Int = record {
        delegate.fetchDirection
    }

    final override fun getFetchSize(): Int = record {
        delegate.fetchSize
    }

    final override fun getGeneratedKeys(): ResultSet = record {
        connection.RecordingResultSet(delegate.generatedKeys)
    }

    final override fun getMaxFieldSize(): Int = record {
        delegate.maxFieldSize
    }

    final override fun getMaxRows(): Int = record {
        delegate.maxRows
    }

    override fun getMoreResults(): Boolean = record {
        delegate.moreResults
    }

    override fun getMoreResults(current: Int): Boolean = record {
        delegate.getMoreResults(current)
    }

    final override fun getQueryTimeout(): Int = record {
        delegate.queryTimeout
    }

    final override fun getResultSet(): ResultSet = record {
        connection.RecordingResultSet(delegate.resultSet)
    }

    final override fun getResultSetConcurrency(): Int = record {
        delegate.resultSetConcurrency
    }

    final override fun getResultSetType(): Int = record {
        delegate.resultSetType
    }

    final override fun getResultSetHoldability(): Int = record {
        delegate.resultSetHoldability
    }

    final override fun getUpdateCount(): Int {
        record()
        return delegate.updateCount
    }

    final override fun getWarnings(): SQLWarning? = record {
        delegate.warnings
    }

    final override fun isPoolable(): Boolean = record {
        delegate.isPoolable
    }

    final override fun isClosed(): Boolean = record {
        delegate.isClosed
    }

    final override fun isCloseOnCompletion(): Boolean = record {
        delegate.isCloseOnCompletion
    }


    final override fun setCursorName(name: String?) {
        record(name)
        delegate.setCursorName(name)
    }

    final override fun setEscapeProcessing(enable: Boolean) {
        record(enable)
        delegate.setEscapeProcessing(enable)
    }

    final override fun setFetchDirection(direction: Int) {
        record(direction)
        delegate.fetchDirection = direction
    }

    final override fun setFetchSize(rows: Int) {
        record(rows)
        delegate.fetchSize = rows
    }


    final override fun setMaxFieldSize(max: Int) = record(max) {
        delegate.maxFieldSize = max
    }

    final override fun setMaxRows(max: Int) {
        record(max)
        delegate.maxRows = max
    }


    final override fun setPoolable(poolable: Boolean) {
        record(poolable)
        delegate.isPoolable = poolable
    }

    final override fun setQueryTimeout(seconds: Int) {
        record(seconds)
        delegate.queryTimeout = seconds
    }

}