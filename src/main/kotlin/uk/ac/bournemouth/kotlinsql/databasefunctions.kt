/*
 * Copyright (c) 2017.
 *
 * This file is part of ProcessManager.
 *
 * This file is licenced to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You should have received a copy of the license with the source distribution.
 * Alternatively, you may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

@file:Suppress("ClassName", "FunctionName", "FunctionName")

package uk.ac.bournemouth.kotlinsql

import uk.ac.bournemouth.kotlinsql.sql.EvaluatableDBTransaction
import uk.ac.bournemouth.kotlinsql.monadic.EmptyDBTransaction
import uk.ac.bournemouth.util.kotlin.sql.StatementHelper
import uk.ac.bournemouth.util.kotlin.sql.impl.MonadicDBConnection
import uk.ac.bournemouth.util.kotlin.sql.use
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import javax.sql.DataSource


internal fun <T> Database.SelectStatement.executeHelper(connection: MonadicDBConnection<*>,
                                                        block: T,
                                                        invokeHelper: (ResultSet, T) -> Unit): Boolean {
    return connection.prepareStatement(toSQL()) {
        val select: Database.SelectStatement = this@executeHelper
        select.setParams(this)
        execute { rs ->
            if (rs.next()) {
                do {
                    invokeHelper(rs, block)
                } while (rs.next())
                true
            } else {
                false
            }
        }
    }
}

/**
 * Get a single element or a null value according to the conversion function passed. This will throw if the result count
 * is larger than 1.
 *
 * @param connection The connection to use
 * @param resultHandler The function that transforms the query result into a result object.
 *
 * @throws SQLException If there are more results than expected, or if there is an underlying SQL error.
 */
fun <R> Database.SelectStatement.getSingleListOrNull(connection: MonadicDBConnection<*>,
                                                     resultHandler: (List<Column<*, *, *>>, List<Any?>) -> R): R? {
    return connection.prepareStatement(toSQL()) {
        setParams(this)
        execute { rs ->
            if (!rs.next()) return null
            val columns = select.columns

            val data = columns.mapIndexed { i, column -> column.type.fromResultSet(rs, i + 1) }
            val result = resultHandler(columns.toList(), data)
            if (rs.next()) throw SQLException("More results than expected")
            return result
        }
    }
}


inline fun <DB: Database, R> DB.connect(datasource: DataSource, block: EmptyDBTransaction<DB, Unit>.() -> R): R {
    val connection = datasource.connection
    var doCommit = true
    try {
        return MonadicDBConnection(connection, this).block()
    } catch (e: Exception) {
        try {
            connection.rollback()
        } finally {
            connection.close()
            doCommit = false
        }
        throw e
    } finally {
        if (doCommit) connection.commit()
        connection.close()
    }
}


fun <DB : Database, In> EmptyDBTransaction<DB, In>.listSequence(queryGen: DB.(In)-> Database.SelectStatement): EvaluatableDBTransaction<DB, Sequence<List<Any?>>> {
    return sequenceHelper(queryGen) { query, rs ->
        query.select.columns.mapIndexed { index, col ->
            col.fromResultSet(rs, index + 1)
        }
    }
}

fun <DB : Database, In, T : Any, C : Column<T, *, C>> EmptyDBTransaction<DB, In>.query(queryGen: DB.(In) -> Database.Select1<T, *, C>): EvaluatableDBTransaction<DB, Sequence<T>> {
    return sequenceHelper(queryGen) { query, rs -> query.select.col1.fromResultSet(rs, 1)!! }
}

fun <DB: Database, T, R: Any> EmptyDBTransaction<DB, T>.insert(keyId: Column<R,*, *>, stmtGen: DB.(T)-> Database.Insert): EvaluatableDBTransaction<DB, Sequence<R>> {
    return map {
        db.stmtGen(it).executeSeq(connection, keyId)
    }
}

fun <DB: Database, T, K: Any, R> EmptyDBTransaction<DB, T>.insert(
    keyId: Column<K, *, *>,
    autogeneratedKeys: (K?) -> R,
    stmtGen: DB.(T) -> Database.Insert
                                                             ): EvaluatableDBTransaction<DB, Sequence<R>> {
    return map { db.stmtGen(it).executeSeq(connection, keyId, autogeneratedKeys) }
}

fun <DB: Database, T> EmptyDBTransaction<DB, T>.update(stmtGen: DB.(T)-> Database.UpdatingStatement): EvaluatableDBTransaction<DB, Int> {
    return map { db.stmtGen(it).executeUpdate(connection) }
}


internal fun <S: Database.SelectStatement, DB : Database, In, T> EmptyDBTransaction<DB, In>.sequenceHelper(
    queryGen: DB.(In) -> S,
    resultSetToSequence: (S, ResultSet) -> T
                                                                                                          ): EvaluatableDBTransaction<DB, Sequence<T>> {
    return map {
        val query = db.queryGen(it)
        val sql = query.toSQL()
        connection.rawConnection.prepareStatement(sql).use<PreparedStatement,Sequence<T>> { rawPrepStatement ->
            val statement = StatementHelper(rawPrepStatement, sql)
            query.setParams(statement)
            val rs = statement.executeQuery().also { closeOnFinish(it) }
            if (rs.next()) {
                sequence {
                    try {
                        do {
                            yield(resultSetToSequence(query, rs))
                        } while (rs.next())
                    } finally {
                        rs.close()
                    }
                }
            } else {
                rs.close() // Don't forget to close
                emptySequence()
            }
        }
    }
}

@Suppress("unused")
        /**
         * Get a single result item, but don't accept an empty result. Otherwise this is the same as [getSingleListOrNull].
         *
         * @see getSingleListOrNull
         */
fun <R> Database.SelectStatement.getSingleList(connection: MonadicDBConnection<*>,
                                               resultHandler: (List<Column<*, *, *>>, List<Any?>) -> R): R {
    return getSingleListOrNull(connection, resultHandler) ?: throw NoSuchElementException()
}


private fun ColumnRef<*, *, *>.name(prefixMap: Map<String, String>?): String {
    return prefixMap?.run { get(table._name)?.let { "$it.`$name`" } } ?: "`$name`"
}

private fun TableRef.name(prefixMap: Map<String, String>?): String {
    return prefixMap?.let { map -> map[this._name]?.let { "`$_name` AS $it" } } ?: "`$_name`"
}

@Deprecated("Use companion member", ReplaceWith("IColumnType.fromSqlType(sqlType)"))
fun columnType(sqlType:Int): IColumnType<*,*,*> = IColumnType.fromSqlType(sqlType)
