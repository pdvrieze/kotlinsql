/*
 * Copyright (c) 2020. 
 *
 * This file is part of kotlinsql.
 *
 * This file is licenced to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You should have received a copy of the license with the source distribution.
 * Alternatively, you may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package uk.ac.bournemouth.kotlinsql.test

import java.lang.Exception
import java.sql.*
import java.util.*
import java.util.concurrent.Executor

class DummyConnection : Connection {
    val actions = mutableListOf<Action>()
    private var isClosed = false
    private var autoCommit = true
    private var nextSavePoint = 1

    private fun <R> recordRes(result: R, vararg args: Any?): R {
        val calledFunction = Exception().stackTrace[1].methodName
        val ac = DummyConnection.StringAction("$calledFunction(${args.joinToString()}) -> $result")
        actions.add(ac)
        return result
    }

    private fun record(vararg args: Any?) {
        val calledFunction = Exception().stackTrace[1].methodName
        val ac = DummyConnection.StringAction("$calledFunction(${args.joinToString()})")
        actions.add(ac)
    }


    override fun prepareStatement(sql: String): PreparedStatement {
        return DummyPreparedStatement(sql).also { actions.add(it) }
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return DummyPreparedStatement(sql, resultSetType, resultSetConcurrency).also { actions.add(it) }
    }

    override fun prepareStatement(
        sql: String,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
                                 ): PreparedStatement {
        return DummyPreparedStatement(
            sql,
            resultSetType,
            resultSetConcurrency,
            resultSetHoldability
                                     ).also { actions.add(it) }
    }

    override fun prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement {
        return DummyPreparedStatement(sql).also { actions.add(it) }
    }

    override fun prepareStatement(sql: String, columnIndexes: IntArray): PreparedStatement {
        return DummyPreparedStatement(sql).also { actions.add(it) }
    }

    override fun prepareStatement(sql: String, columnNames: Array<out String>): PreparedStatement {
        return DummyPreparedStatement(sql).also { actions.add(it) }
    }

    override fun rollback() {
        actions.add(Rollback)
    }

    override fun rollback(savepoint: Savepoint) {
        actions.add(Rollback(savepoint))
    }

    override fun getHoldability(): Int {
        TODO("not implemented")
    }

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        TODO("not implemented")
    }

    override fun commit() {
        actions.add(Commit)
    }

    override fun <T : Any?> unwrap(iface: Class<T>?): T {
        TODO("not implemented")
    }

    override fun setTransactionIsolation(level: Int) {
        TODO("not implemented")
    }

    override fun setAutoCommit(autoCommit: Boolean) {
        this.autoCommit = autoCommit
        actions.add(SetAutoCommit(autoCommit))
    }

    override fun abort(executor: Executor?) {
        TODO("not implemented")
    }

    override fun prepareCall(sql: String?): CallableStatement {
        TODO("not implemented")
    }

    override fun prepareCall(sql: String?, resultSetType: Int, resultSetConcurrency: Int): CallableStatement {
        TODO("not implemented")
    }

    override fun prepareCall(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
                            ): CallableStatement {
        TODO("not implemented")
    }

    override fun getClientInfo(name: String?): String {
        TODO("not implemented")
    }

    override fun getClientInfo(): Properties {
        TODO("not implemented")
    }

    override fun getAutoCommit(): Boolean {
        return autoCommit.also { actions.add(StringAction("getAutoCommit() -> $it"))}
    }

    override fun setCatalog(catalog: String?) {
        TODO("not implemented")
    }

    override fun getWarnings(): SQLWarning {
        TODO("not implemented")
    }

    override fun getCatalog(): String {
        TODO("not implemented")
    }

    override fun setHoldability(holdability: Int) {
        TODO("not implemented")
    }

    override fun getSchema(): String {
        TODO("not implemented")
    }

    override fun isValid(timeout: Int): Boolean {
        TODO("not implemented")
    }

    override fun close() {
        isClosed = true
        actions.add(StringAction("Connection.close()"))
    }

    override fun isClosed(): Boolean {
        return isClosed
    }

    override fun createNClob(): NClob {
        TODO("not implemented")
    }

    override fun createBlob(): Blob {
        TODO("not implemented")
    }

    override fun createArrayOf(typeName: String?, elements: Array<out Any>?): java.sql.Array {
        TODO("not implemented")
    }

    override fun setReadOnly(readOnly: Boolean) {
        TODO("not implemented")
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        TODO("not implemented")
    }

    override fun nativeSQL(sql: String?): String {
        TODO("not implemented")
    }

    override fun createStruct(typeName: String?, attributes: Array<out Any>?): Struct {
        TODO("not implemented")
    }

    override fun setClientInfo(name: String?, value: String?) {
        TODO("not implemented")
    }

    override fun setClientInfo(properties: Properties?) {
        TODO("not implemented")
    }

    override fun releaseSavepoint(savepoint: Savepoint) {
        actions.add(ReleaseSavepoint(savepoint))
    }

    override fun createClob(): Clob {
        TODO("not implemented")
    }

    override fun isReadOnly(): Boolean {
        TODO("not implemented")
    }

    override fun createStatement(): Statement {
        TODO("not implemented")
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement {
        TODO("not implemented")
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement {
        TODO("not implemented")
    }

    override fun setSavepoint(): Savepoint {
        val sp = DummySavePoint(nextSavePoint)
        nextSavePoint++
        actions.add(sp)
        return sp
    }

    override fun setSavepoint(name: String?): Savepoint {
        TODO("not implemented")
    }

    override fun getTypeMap(): MutableMap<String, Class<*>> {
        TODO("not implemented")
    }

    override fun clearWarnings() {
        TODO("not implemented")
    }

    override fun getMetaData(): DatabaseMetaData {
        TODO("not implemented")
    }

    override fun getTransactionIsolation(): Int {
        TODO("not implemented")
    }

    override fun setSchema(schema: String?) {
        TODO("not implemented")
    }

    override fun getNetworkTimeout(): Int {
        TODO("not implemented")
    }

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        TODO("not implemented")
    }

    override fun createSQLXML(): SQLXML {
        TODO("not implemented")
    }

    interface Action

    inner class DummyPreparedStatement(
        sql: String,
        resultSetType: Int = ResultSet.TYPE_SCROLL_INSENSITIVE,
        resultSetConcurrency: Int = ResultSet.CONCUR_UPDATABLE,
        resultSetHoldability: Int = ResultSet.CLOSE_CURSORS_AT_COMMIT
                                      ) :
        AbstractDummyPreparedStatement(this, sql, resultSetType, resultSetConcurrency), Action {
        override fun recordAction(action: Action) {
            actions.add(action)
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is DummyPreparedStatement) return false
            return true
        }

        override fun hashCode(): Int {
            return javaClass.hashCode()
        }

        override fun toString(): String {
            return "DummyPreparedStatement(\"$sql\")"
        }


    }

    inner class DummyResultSet(query: String): AbstractDummyResultSet(query), Action {
        override fun recordAction(action: Action) {
            actions.add(action)
        }
    }

    data class StringAction(val string: String) : Action

    fun Rollback(savePoint: Savepoint) = RollbackImpl(savePoint.savepointName)
    data class RollbackImpl(val savePoint: String?) : Action

    object Commit : Action {
        override fun toString(): String = "Commit"
    }

    fun SetAutoCommit(autoCommit: Boolean) = when(autoCommit) {
        true -> SetAutoCommit.TRUE
        else -> SetAutoCommit.FALSE
    }

    enum class SetAutoCommit : Action {
        TRUE,
        FALSE;

        override fun toString(): String {
            return "SetAutoCommit($name)"
        }
    }

    data class DummySavePoint(private val id: Int): Savepoint, Action {
        override fun getSavepointId(): Int = id

        override fun getSavepointName(): String = "savepoint$id"
    }

    data class ReleaseSavepoint(val savepointId: Int): Action {
        constructor(savepoint: Savepoint): this(savepoint.savepointId)
        override fun toString(): String {
            return "ReleaseSavepoint(${savepointId})"
        }
    }

    companion object {
        val Rollback = RollbackImpl(null)
    }
}
